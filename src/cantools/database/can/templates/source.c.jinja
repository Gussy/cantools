/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version {{ version }} {{ date }}.
 */

#include <string.h>

#include "{{ header }}"
{% for k in pack_helpers|sort %}
static inline uint8_t pack_{{ k[0] }}_shift_u{{ k[1] }}(
    uint{{ k[1] }}_t value,
    uint8_t shift,
    uint8_t mask)
{
{%- if k[0] == "left" %}
    return (uint8_t)((uint8_t)(value << shift) & mask);
{%- else %}
    return (uint8_t)((uint8_t)(value >> shift) & mask);
{%- endif %}  
}
{% endfor %}
{%- for k in unpack_helpers|sort %}
static inline uint{{ k[1] }}_t unpack_{{ k[0] }}_shift_u{{ k[1] }}(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
{%- if k[0] == "left" %}
    return (uint{{ k[1] }}_t)((uint{{ k[1] }}_t)(value & mask) << shift);
{%- else %}
    return (uint{{ k[1] }}_t)((uint{{ k[1] }}_t)(value & mask) >> shift);
{%- endif %}  
}
{% endfor %}

{%- for d in definitions %}
{%- if d.message_length > 0 %}
{%- if d.sender %}
int {{ database_name }}_{{ d.message_name }}_pack(
    uint8_t *dst_p,
    const struct {{ database_name }}_{{ d.message_name }}_t *src_p,
    size_t size)
{
{%- if not d.pack_body %}
    (void)src_p;


{%- endif %} 
{{ d.pack_variables}}
    if (size < {{ d.message_length }}u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, {{ d.message_length }});
{{ d.pack_body}}
    return ({{ d.message_length }});
}
{%- endif %}
{%- if d.receiver %}
int {{ database_name }}_{{ d.message_name }}_unpack(
    struct {{ database_name }}_{{ d.message_name }}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
{%- if not d.unpack_body %}
    (void)dst_p;
    (void)src_p;


{%- endif %} 
{{ d.unpack_variables }}
    if (size < {{ d.message_length }}u) {
        return (-EINVAL);
    }
{{ d.unpack_body }}
    return (0);
}
{%- endif %}
int {{ database_name }}_{{ d.message_name }}_init(struct {{ database_name }}_{{ d.message_name }}_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct {{ database_name }}_{{ d.message_name }}_t));
{%- for s in d.signal_definitions %}
{%- if s.initial %}
    msg_p->{{ s.signal_name }} = {{ s.raw_initial }};
{%- endif %}
{%- endfor %}

    return 0;
}
{%- else %}
int {{ database_name }}_{{ d.message_name }}_pack(
    uint8_t *dst_p,
    const struct {{ database_name }}_{{ d.message_name }}_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int {{ database_name }}_{{ d.message_name }}_unpack(
    struct {{ database_name }}_{{ d.message_name }}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}
{%- endif %}


{%- for s in d.signal_definitions %}
{%- if floating_point_numbers %}
{%- if d.sender %}
{{ s.type_name }} {{ database_name }}_{{ d.message_name }}_{{ s.signal_name }}_encode({{ s.floating_point_type }} value)
{
    return ({{ s.type_name }})({{ s.encode }});
}
{%- endif %}
{%- if d.node_name is none or s.receiver %}
{{ s.floating_point_type }} {{ database_name }}_{{ d.message_name }}_{{ s.signal_name }}_decode({{ s.type_name }} value)
{
    return ({{ s.decode }});
}
{%- endif %}
{%- endif %}
{%- if d.sender or s.receiver %}
bool {{ database_name }}_{{ d.message_name }}_{{ s.signal_name }}_is_in_range({{ s.type_name }} value)
{
{%- if s.check == 'true' %}
    (void)value;


{%- endif %}
    return ({{ s.check }});
}
{%- endif %}
{% endfor %}
{% endfor %}

